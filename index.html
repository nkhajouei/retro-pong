<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Paddle Ball</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a; /* Dark background for a retro feel */
            margin: 0;
            font-family: 'Courier New', Courier, monospace; /* Retro font */
            color: #fff;
            overflow: hidden; /* Prevent scrollbars if canvas is slightly too big */
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid #333;
            padding: 20px;
            background-color: #0d0d0d;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3); /* Greenish retro glow */
        }
        canvas {
            background-color: #000;
            display: block; /* Removes extra space below canvas */
            border: 2px solid #0f0; /* Bright green border for the game area */
            max-width: 100%;
            max-height: 80vh; /* Limit height to prevent excessive vertical space */
            aspect-ratio: 4 / 3; /* Common old TV aspect ratio */
            border-radius: 5px;
        }
        #controlsInfo, #scoreBoard, #messageArea {
            margin-top: 15px;
            font-size: 1em; /* Adjusted for better readability */
            color: #0f0; /* Green text */
            text-align: center;
        }
        #controlsInfo p, #scoreBoard p, #messageArea p {
            margin: 5px 0;
        }
        .button {
            background-color: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            margin: 10px 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            transition: background-color 0.3s, color 0.3s;
        }
        .button:hover {
            background-color: #0f0;
            color: #000;
        }
        .button:active {
            transform: translateY(1px);
        }
        #messageArea {
            font-size: 1.2em;
            font-weight: bold;
            min-height: 20px; /* Reserve space for messages */
        }
    </style>
</head>
<body>
    <div id="gameContainer" class="rounded-lg shadow-lg">
        <h1 class="text-3xl font-bold text-green-400 mb-4">Retro Paddle Ball</h1>
        <canvas id="gameCanvas"></canvas>
        <div id="scoreBoard" class="text-lg">
            <p>Player 1: <span id="player1Score">0</span> - Player 2: <span id="player2Score">0</span></p>
        </div>
        <div id="messageArea" class="text-xl h-8">Press Enter to Start</div>
        <div id="controlsInfo" class="text-sm">
            <p>Left Paddle: S (Up), X (Down)</p>
            <p>Right Paddle: J (Up), M (Down)</p>
            <p>Start/Restart Ball: Enter</p>
        </div>
        <button id="resetScoreButton" class="button">Reset Scores</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageArea = document.getElementById('messageArea');
        const player1ScoreDisplay = document.getElementById('player1Score');
        const player2ScoreDisplay = document.getElementById('player2Score');
        const resetScoreButton = document.getElementById('resetScoreButton');

        // Game settings
        let paddleHeight = 80;
        const paddleWidth = 10;
        const ballRadius = 7;
        const initialBallSpeedMagnitude = 2; // MODIFIED: Slower initial speed
        let currentBallSpeedX = initialBallSpeedMagnitude; 
        let currentBallSpeedY = initialBallSpeedMagnitude; 
        const paddleSpeed = 6;
        const maxBallSpeed = 8; // MODIFIED: Slightly reduced max speed
        const speedIncrement = 0.15; // MODIFIED: Slower speed increment

        // Paddle objects
        let paddle1 = {
            x: 10,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            dy: 0 
        };

        let paddle2 = {
            x: canvas.width - paddleWidth - 10,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            dy: 0 
        };

        // Ball object
        let ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: ballRadius,
            dx: currentBallSpeedX,
            dy: currentBallSpeedY
        };

        let player1Score = 0;
        let player2Score = 0;
        let gameStarted = false;
        let ballInPlay = false;

        // Key states
        const keysPressed = {};

        // --- Drawing Functions ---
        function drawPaddle(x, y, width, height) {
            ctx.fillStyle = '#0f0'; 
            ctx.fillRect(x, y, width, height);
        }

        function drawBall(x, y, radius) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#0f0'; 
            ctx.fill();
            ctx.closePath();
        }

        function drawNet() {
            ctx.beginPath();
            ctx.setLineDash([5, 15]); 
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.strokeStyle = '#333'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
            ctx.setLineDash([]); 
        }

        // --- Game Logic ---
        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ballInPlay = false;
            
            let angle = (Math.random() * Math.PI / 2) - (Math.PI / 4); 
            const direction = (Math.random() < 0.5) ? 1 : -1; 
            
            currentBallSpeedX = initialBallSpeedMagnitude * Math.cos(angle) * direction; // Use magnitude and angle
            currentBallSpeedY = initialBallSpeedMagnitude * Math.sin(angle);
            // Ensure a minimum horizontal speed to prevent overly vertical movement
            if (Math.abs(currentBallSpeedX) < initialBallSpeedMagnitude / 2) {
                 currentBallSpeedX = (initialBallSpeedMagnitude / 2) * direction;
            }


            ball.dx = currentBallSpeedX;
            ball.dy = currentBallSpeedY;
            messageArea.textContent = 'Press Enter to Serve';
        }

        function updatePaddleMovement() {
            // Left Paddle (Paddle 1)
            if (keysPressed['s'] || keysPressed['S']) {
                paddle1.y -= paddleSpeed;
            }
            if (keysPressed['x'] || keysPressed['X']) {
                paddle1.y += paddleSpeed;
            }

            // Right Paddle (Paddle 2)
            if (keysPressed['j'] || keysPressed['J']) {
                paddle2.y -= paddleSpeed;
            }
            if (keysPressed['m'] || keysPressed['M']) {
                paddle2.y += paddleSpeed;
            }

            paddle1.y = Math.max(0, Math.min(canvas.height - paddle1.height, paddle1.y));
            paddle2.y = Math.max(0, Math.min(canvas.height - paddle2.height, paddle2.y));
        }
        
        function updateBallPosition() {
            if (!ballInPlay) return;

            ball.x += ball.dx;
            ball.y += ball.dy;

            if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
                ball.dy *= -1;
                if (ball.y + ball.radius > canvas.height) ball.y = canvas.height - ball.radius;
                if (ball.y - ball.radius < 0) ball.y = ball.radius;
            }

            // Left paddle collision
            if (ball.dx < 0 && // Moving left
                ball.x - ball.radius < paddle1.x + paddle1.width &&
                ball.x + ball.radius > paddle1.x && // Ensures ball is somewhat overlapping horizontally
                ball.y + ball.radius > paddle1.y &&
                ball.y - ball.radius < paddle1.y + paddle1.height) {
                
                ball.x = paddle1.x + paddle1.width + ball.radius; // Prevent sticking
                ball.dx *= -1;
                
                if (Math.abs(ball.dx) < maxBallSpeed) ball.dx += Math.sign(ball.dx) * speedIncrement;
                // Only increase Y speed if it's not already too fast, and maintain its current direction
                if (Math.abs(ball.dy) < maxBallSpeed && ball.dy !== 0) {
                     ball.dy += Math.sign(ball.dy) * speedIncrement / 2; // Y speed increases less
                } else if (ball.dy === 0 && Math.abs(ball.dx) < maxBallSpeed) { // If ball is moving straight, add a bit of Y
                    ball.dy += speedIncrement / 2 * (Math.random() < 0.5 ? -1 : 1);
                }
                
                let deltaY = ball.y - (paddle1.y + paddle1.height / 2);
                ball.dy += deltaY * 0.1; // MODIFIED: Reduced influence of paddle hit location on Y speed
                 // Clamp ball.dy to prevent extreme angles
                ball.dy = Math.max(-maxBallSpeed * 0.75, Math.min(maxBallSpeed * 0.75, ball.dy));
            }

            // Right paddle collision
            if (ball.dx > 0 && // Moving right
                ball.x + ball.radius > paddle2.x &&
                ball.x - ball.radius < paddle2.x + paddle2.width && // Ensures ball is somewhat overlapping horizontally
                ball.y + ball.radius > paddle2.y &&
                ball.y - ball.radius < paddle2.y + paddle2.height) {
                
                ball.x = paddle2.x - ball.radius; // Prevent sticking
                ball.dx *= -1;

                if (Math.abs(ball.dx) < maxBallSpeed) ball.dx += Math.sign(ball.dx) * speedIncrement;
                if (Math.abs(ball.dy) < maxBallSpeed && ball.dy !== 0) {
                    ball.dy += Math.sign(ball.dy) * speedIncrement / 2;
                } else if (ball.dy === 0 && Math.abs(ball.dx) < maxBallSpeed) {
                     ball.dy += speedIncrement / 2 * (Math.random() < 0.5 ? -1 : 1);
                }
                
                let deltaY = ball.y - (paddle2.y + paddle2.height / 2);
                ball.dy += deltaY * 0.1; // MODIFIED: Reduced influence
                ball.dy = Math.max(-maxBallSpeed * 0.75, Math.min(maxBallSpeed * 0.75, ball.dy));
            }

            if (ball.x + ball.radius < 0) { 
                player2Score++;
                player2ScoreDisplay.textContent = player2Score;
                resetBall();
            } else if (ball.x - ball.radius > canvas.width) { 
                player1Score++;
                player1ScoreDisplay.textContent = player1Score;
                resetBall();
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawNet(); 
            drawPaddle(paddle1.x, paddle1.y, paddle1.width, paddle1.height);
            drawPaddle(paddle2.x, paddle2.y, paddle2.width, paddle2.height);
            drawBall(ball.x, ball.y, ball.radius);

            if (gameStarted) {
                updatePaddleMovement();
                updateBallPosition();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        function handleKeyDown(e) {
            keysPressed[e.key.toLowerCase()] = true; // Store keys in lowercase for consistency

            if (e.key === 'Enter') {
                if (!gameStarted) {
                    gameStarted = true;
                    // ballInPlay = true; // Moved to after resetBall
                    messageArea.textContent = ''; 
                    resetBall(); 
                    ballInPlay = true; 
                } else if (!ballInPlay) {
                    ballInPlay = true;
                    messageArea.textContent = '';
                    if(ball.dx === 0 && ball.dy === 0) { // Check if ball speeds are zero
                        resetBall(); 
                    }
                }
            }
        }

        function handleKeyUp(e) {
            keysPressed[e.key.toLowerCase()] = false; // Store keys in lowercase
        }
        
        resetScoreButton.addEventListener('click', () => {
            player1Score = 0;
            player2Score = 0;
            player1ScoreDisplay.textContent = player1Score;
            player2ScoreDisplay.textContent = player2Score;
            gameStarted = false; // Stop game logic
            messageArea.textContent = 'Press Enter to Start';
            resetBall(); 
        });

        // --- Initialization ---
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth - 40; 
            const aspectRatio = 4 / 3;
            
            canvas.width = containerWidth;
            canvas.height = containerWidth / aspectRatio;

            const maxHeight = window.innerHeight * 0.7; 
            if (canvas.height > maxHeight) {
                canvas.height = maxHeight;
                canvas.width = maxHeight * aspectRatio;
            }

            paddleHeight = canvas.height / 7.5; 
            paddle1.height = paddleHeight;
            paddle2.height = paddleHeight;

            paddle1.y = canvas.height / 2 - paddle1.height / 2;
            paddle2.x = canvas.width - paddle2.width - 10;
            paddle2.y = canvas.height / 2 - paddle2.height / 2;
            
            // Reset ball position and speed according to new canvas size
            // but only if game is not actively in play or just started
            if (!ballInPlay || !gameStarted) {
                 resetBall();
            } else {
                // If ball is in play, try to adjust its position proportionally
                // This is a simple adjustment, might need refinement for perfect feel
                ball.x = (ball.x / (canvas.width / aspectRatio)) * canvas.width; // old width was based on old aspect ratio logic
                ball.y = (ball.y / (canvas.width / aspectRatio / aspectRatio)) * canvas.height; // old height was based on old aspect ratio logic
            }
        }
        
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('resize', resizeCanvas);
        
        resizeCanvas(); 
        messageArea.textContent = 'Press Enter to Start';

        gameLoop();
    </script>
</body>
</html>
